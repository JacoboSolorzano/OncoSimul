Some of the variables:

g: number of genes
sd, mu
c: factor which affects the penalty of the hamming distance from the reference
reference: chooses which combination is the reference: random, a vector provided by user or max (all ones)

first: arg check, g cannot be null
sets wt_is_1 based on user selection, if not specified chooses first one (match.args does this as far as I know, needs closer inspection)
generate matrix of genotypes (m)

while loop:

	f_r: generate as many random numbers from a normal distribution of mean mu and sd of sd as rows from matrix (number of possible genotypes)
	If reference is a character of length 1, to generate refI:

		If ref is random, choose one of the genotypes as ref
		If it is max, ref is the genotype with all ones
		If it is random2, some other function included in the package (create_eq_ref) generates it

	else(ie a vector was put as as ref).

	referenceI is the reference for the calculations

	d_ref: vector (I think). Each position is the corresponding hamming distance from the reference for each genotype (ie the first element is the hamming distance of the genotype of the first row of the matrix to the referenceI, and so on). Done with summing the absolute value of the difference of the vectors. So if we have genotype (1,0,1) and reference (0,1,1) we get: (1,-1,0); absolute value: 1,1,0, sum: 2. Quite ingenious.

	fi: a vector consisting of the fitness of each genotype (first element is the fitness of the first genotype in the matrix, and so on). Sum of f_r and f_det

	Next: adjustments on fi depending on other variables

	scale: if scale is not null:

		First: subtract the minimun of each element and divide by the diff in max and min. Minimum value will be 0, maximum value will be 1
		Next: sum the first element of scale and mutiply times the difference of the second element of scale minus the first element of scale

	wt_is_1: Based on the choices shifts the values, with wild type (fi[1], corresponds to the genotype with all zeros(no mutations)) always being 1. Force and divide look like can cause some problems based on the variable scale. With option "no" this is skipped

	truncate at 0: sets values of 0 or less as 1e-9

	log: if is true, applies a log transform on the values

	bind the fitnesses to the matrix

	Next: some functions from another package looks like, will break the while loop. Needs closer inspection!
	Assign to m the class "genotype_fitness_matrix", probably for graphing purposes
	returns m



